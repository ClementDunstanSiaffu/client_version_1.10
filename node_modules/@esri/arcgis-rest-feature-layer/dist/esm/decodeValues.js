/* Copyright (c) 2018 Environmental Systems Research Institute, Inc.
 * Apache-2.0 */
import { __assign } from "tslib";
import { getLayer } from "./getLayer";
/**
 * ```js
 * import { queryFeatures, decodeValues } from '@esri/arcgis-rest-feature-layer';
 * //
 * const url = `https://sampleserver6.arcgisonline.com/arcgis/rest/services/ServiceRequest/FeatureServer/0`
 * queryFeatures({ url })
 *   .then(queryResponse => {
 *     decodeValues({
 *       url,
 *       queryResponse
 *     })
 *       .then(decodedResponse)
 *   })
 * ```
 * Replaces the raw coded domain values in a query response with descriptions (for legibility).
 *
 * @param requestOptions - Options for the request.
 * @returns A Promise that will resolve with the addFeatures response.
 */
export function decodeValues(requestOptions) {
    var prms;
    if (requestOptions.fields) {
        prms = Promise.resolve(requestOptions.fields);
    }
    else {
        prms = getLayer({ url: requestOptions.url }).then(function (metadata) {
            return metadata.fields;
        });
    }
    return prms.then(function (fields) {
        // extract coded value domains
        var domains = extractCodedValueDomains(fields);
        if (Object.keys(domains).length < 1) {
            // no values to decode
            return requestOptions.queryResponse;
        }
        // don't mutate original features
        var decodedFeatures = requestOptions.queryResponse.features.map(function (feature) {
            var decodedAttributes = {};
            for (var key in feature.attributes) {
                /* istanbul ignore next */
                if (!Object.prototype.hasOwnProperty.call(feature.attributes, key))
                    continue;
                var value = feature.attributes[key];
                var domain = domains[key];
                decodedAttributes[key] =
                    value !== null && domain ? decodeValue(value, domain) : value;
            }
            // merge decoded attributes into the feature
            return __assign(__assign({}, feature), { attributes: decodedAttributes });
        });
        // merge decoded features into the response
        return __assign(__assign({}, requestOptions.queryResponse), { features: decodedFeatures });
    });
}
function extractCodedValueDomains(fields) {
    return fields.reduce(function (domains, field) {
        var domain = field.domain;
        if (domain && domain.type === "codedValue") {
            domains[field.name] = domain;
        }
        return domains;
    }, {});
}
// TODO: add type for domain?
function decodeValue(value, domain) {
    var codedValue = domain.codedValues.find(function (d) {
        return value === d.code;
    });
    return codedValue ? codedValue.name : value;
}
//# sourceMappingURL=decodeValues.js.map