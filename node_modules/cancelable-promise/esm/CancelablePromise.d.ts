declare class CancelablePromiseInternal<T = any> {
    #private;
    constructor({ executor, internals, promise, }: {
        executor?: (resolve: (value: T | PromiseLike<T>) => void, reject: (reason?: any) => void, onCancel: (cancelHandler: () => void) => void) => void;
        internals?: Internals;
        promise?: Promise<T>;
    });
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1> | CancelablePromise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2> | CancelablePromise<TResult2>) | undefined | null): CancelablePromise<TResult1 | TResult2>;
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult> | CancelablePromise<TResult>) | undefined | null): CancelablePromise<T | TResult>;
    finally(onfinally?: (() => void) | undefined | null, runWhenCanceled?: boolean): CancelablePromise<T>;
    cancel(): void;
    isCanceled(): boolean;
}
export declare class CancelablePromise<T = any> extends CancelablePromiseInternal<T> {
    static all: <T_1 extends [] | readonly unknown[]>(values: T_1) => CancelablePromise<{ -readonly [P in keyof T_1]: Awaited<T_1[P]>; }>;
    static allSettled: {
        <T_1 extends [] | readonly unknown[]>(values: T_1): CancelablePromise<{ -readonly [P in keyof T_1]: PromiseSettledResult<Awaited<T_1[P]>>; }>;
        <T_2>(values: Iterable<T_2 | PromiseLike<T_2> | CancelablePromise<T_2>>): CancelablePromise<PromiseSettledResult<Awaited<T_2>>[]>;
    };
    static any: {
        <T_1 extends [] | readonly unknown[]>(values: T_1): CancelablePromise<Awaited<T_1[number]>>;
        <T_2>(values: Iterable<T_2 | PromiseLike<T_2> | CancelablePromise<T_2>>): CancelablePromise<Awaited<T_2>>;
    };
    static race: <T_1 extends [] | readonly unknown[]>(values: T_1) => CancelablePromise<Awaited<T_1[number]>>;
    static resolve: {
        (): CancelablePromise<void>;
        <T_1>(value: T_1 | PromiseLike<T_1> | CancelablePromise<T_1>): CancelablePromise<T_1>;
    };
    static reject: <T_1 = never>(reason?: any) => CancelablePromise<T_1>;
    static isCancelable: typeof isCancelablePromise;
    constructor(executor: (resolve: (value: T | PromiseLike<T>) => void, reject: (reason?: any) => void, onCancel: (cancelHandler: () => void) => void) => void);
}
export default CancelablePromise;
export declare function cancelable<T = any>(promise: Promise<T>): CancelablePromise<T>;
export declare function isCancelablePromise(promise: any): boolean;
interface Internals {
    isCanceled: boolean;
    onCancelList: any[];
}
