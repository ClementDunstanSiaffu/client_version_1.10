function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }

function _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }

function _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get"); return _classApplyDescriptorGet(receiver, descriptor); }

function _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }

function _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set"); _classApplyDescriptorSet(receiver, descriptor, value); return value; }

function _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError("attempted to " + action + " private field on non-instance"); } return privateMap.get(receiver); }

function _classApplyDescriptorSet(receiver, descriptor, value) { if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError("attempted to set read only private field"); } descriptor.value = value; } }

var _internals = /*#__PURE__*/new WeakMap();

var _promise = /*#__PURE__*/new WeakMap();

class CancelablePromiseInternal {
  constructor(_ref) {
    var {
      executor = () => {},
      internals = defaultInternals(),
      promise = new Promise((resolve, reject) => executor(resolve, reject, onCancel => {
        internals.onCancelList.push(onCancel);
      }))
    } = _ref;

    _classPrivateFieldInitSpec(this, _internals, {
      writable: true,
      value: void 0
    });

    _classPrivateFieldInitSpec(this, _promise, {
      writable: true,
      value: void 0
    });

    this.cancel = this.cancel.bind(this);

    _classPrivateFieldSet(this, _internals, internals);

    _classPrivateFieldSet(this, _promise, promise || new Promise((resolve, reject) => executor(resolve, reject, onCancel => {
      internals.onCancelList.push(onCancel);
    })));
  }

  then(onfulfilled, onrejected) {
    return makeCancelable(_classPrivateFieldGet(this, _promise).then(createCallback(onfulfilled, _classPrivateFieldGet(this, _internals)), createCallback(onrejected, _classPrivateFieldGet(this, _internals))), _classPrivateFieldGet(this, _internals));
  }

  catch(onrejected) {
    return makeCancelable(_classPrivateFieldGet(this, _promise).catch(createCallback(onrejected, _classPrivateFieldGet(this, _internals))), _classPrivateFieldGet(this, _internals));
  }

  finally(onfinally, runWhenCanceled) {
    if (runWhenCanceled) {
      _classPrivateFieldGet(this, _internals).onCancelList.push(onfinally);
    }

    return makeCancelable(_classPrivateFieldGet(this, _promise).finally(createCallback(() => {
      if (onfinally) {
        if (runWhenCanceled) {
          _classPrivateFieldGet(this, _internals).onCancelList = _classPrivateFieldGet(this, _internals).onCancelList.filter(callback => callback !== onfinally);
        }

        return onfinally();
      }
    }, _classPrivateFieldGet(this, _internals))), _classPrivateFieldGet(this, _internals));
  }

  cancel() {
    _classPrivateFieldGet(this, _internals).isCanceled = true;

    var callbacks = _classPrivateFieldGet(this, _internals).onCancelList;

    _classPrivateFieldGet(this, _internals).onCancelList = [];

    for (var callback of callbacks) {
      if (typeof callback === 'function') {
        try {
          callback();
        } catch (err) {
          console.error(err);
        }
      }
    }
  }

  isCanceled() {
    return _classPrivateFieldGet(this, _internals).isCanceled === true;
  }

}

export class CancelablePromise extends CancelablePromiseInternal {
  constructor(executor) {
    super({
      executor
    });
  }

}

_defineProperty(CancelablePromise, "all", function all(iterable) {
  return makeAllCancelable(iterable, Promise.all(iterable));
});

_defineProperty(CancelablePromise, "allSettled", function allSettled(iterable) {
  return makeAllCancelable(iterable, Promise.allSettled(iterable));
});

_defineProperty(CancelablePromise, "any", function any(iterable) {
  return makeAllCancelable(iterable, Promise.any(iterable));
});

_defineProperty(CancelablePromise, "race", function race(iterable) {
  return makeAllCancelable(iterable, Promise.race(iterable));
});

_defineProperty(CancelablePromise, "resolve", function resolve(value) {
  return cancelable(Promise.resolve(value));
});

_defineProperty(CancelablePromise, "reject", function reject(reason) {
  return cancelable(Promise.reject(reason));
});

_defineProperty(CancelablePromise, "isCancelable", isCancelablePromise);

export default CancelablePromise;
export function cancelable(promise) {
  return makeCancelable(promise, defaultInternals());
}
export function isCancelablePromise(promise) {
  return promise instanceof CancelablePromise || promise instanceof CancelablePromiseInternal;
}

function createCallback(onResult, internals) {
  if (onResult) {
    return arg => {
      if (!internals.isCanceled) {
        var result = onResult(arg);

        if (isCancelablePromise(result)) {
          internals.onCancelList.push(result.cancel);
        }

        return result;
      }

      return arg;
    };
  }
}

function makeCancelable(promise, internals) {
  return new CancelablePromiseInternal({
    internals,
    promise
  });
}

function makeAllCancelable(iterable, promise) {
  var internals = defaultInternals();
  internals.onCancelList.push(() => {
    for (var resolvable of iterable) {
      if (isCancelablePromise(resolvable)) {
        resolvable.cancel();
      }
    }
  });
  return new CancelablePromiseInternal({
    internals,
    promise
  });
}

function defaultInternals() {
  return {
    isCanceled: false,
    onCancelList: []
  };
}
//# sourceMappingURL=CancelablePromise.mjs.map